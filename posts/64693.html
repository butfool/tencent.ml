<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lymtics.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"none","post_body":"fadeInUp","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="废话 堆（Heap）是一种重要的数据结构，但是在大学的数据结构中似乎刚好和这种结构擦肩而过，只记得有一个排序叫“堆排序”，并且在数据结构实习中实现过一次。后来刷LeeCode的时候又遇到了这种结构，所以作文以记之。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构之堆">
<meta property="og:url" content="https://blog.lymtics.top/posts/64693.html">
<meta property="og:site_name" content="LYMTICS">
<meta property="og:description" content="废话 堆（Heap）是一种重要的数据结构，但是在大学的数据结构中似乎刚好和这种结构擦肩而过，只记得有一个排序叫“堆排序”，并且在数据结构实习中实现过一次。后来刷LeeCode的时候又遇到了这种结构，所以作文以记之。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-14a6cde25bdff968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-14a6cde25bdff968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-4b11a151bf6c2148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-7515fe1d9f3104ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-d6fd28a1ba7dbb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-26be199ebd40f8bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-9590755bc6109a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/413/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-525f0584ffbdbbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/219/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-9a3b75e40d3f9f04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-51fd43a2d2191488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-7dd89da71927acb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-785a7a6cd104f775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/204/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-d7dae273e1f5a0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/192/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-7eb32c6486a44f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-71783aa7bd24a51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-c28b15dc371b8e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-bfc42e89b5411f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-8b04275965f88961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/208/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-ef711e0072fc773a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/219/format/webp">
<meta property="article:published_time" content="2021-11-24T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-25T04:40:19.161Z">
<meta property="article:author" content="Ren">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/4064751-14a6cde25bdff968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp">


<link rel="canonical" href="https://blog.lymtics.top/posts/64693.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.lymtics.top/posts/64693.html","path":"posts/64693.html","title":"数据结构之堆"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构之堆 | LYMTICS</title>
  



<meta name="referrer" content="no-referrer"/>
<script src="./Cerasus.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LYMTICS</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E5%A0%86"><span class="nav-number">1.</span> <span class="nav-text">认识堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">堆的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">最基本的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%99%AE%E9%80%9A%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">堆和普通树的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A5%E8%87%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%91"><span class="nav-number">2.3.</span> <span class="nav-text">来自数组的树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">更多数学公式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">3.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="nav-number">3.2.</span> <span class="nav-text">删除根节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9"><span class="nav-number">3.3.</span> <span class="nav-text">删除任意节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">实操（代码）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.1.</span> <span class="nav-text">调整位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%A0%86"><span class="nav-number">4.2.</span> <span class="nav-text">构造堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E5%A0%86%E9%A1%B6"><span class="nav-number">4.3.</span> <span class="nav-text">取堆顶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.</span> <span class="nav-text">Java完整实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E8%87%AA%E5%B8%A6API"><span class="nav-number">5.</span> <span class="nav-text">语言自带API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%EF%BC%9ApriorityQueue"><span class="nav-number">5.1.</span> <span class="nav-text">Java：priorityQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ren"
      src="https://s3.bmp.ovh/imgs/2021/11/8c35a2dcbfc9dfd3.jpeg">
  <p class="site-author-name" itemprop="name">Ren</p>
  <div class="site-description" itemprop="description">幸遇三杯酒好，况逢一朵花新。 <br> 片时欢笑且相亲，明日阴晴未定。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lxymtics" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lxymtics" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lxymtics@qq.com" title="E-Mail → mailto:lxymtics@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://xy.lymtics.top/" title="https:&#x2F;&#x2F;xy.lymtics.top&#x2F;" rel="noopener" target="_blank">Mine</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://lymtics.top/meet/" title="https:&#x2F;&#x2F;lymtics.top&#x2F;meet&#x2F;" rel="noopener" target="_blank">Meet</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://docs.lymtics.top/" title="https:&#x2F;&#x2F;docs.lymtics.top&#x2F;" rel="noopener" target="_blank">Docs</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.lymtics.top/posts/64693.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s3.bmp.ovh/imgs/2021/11/8c35a2dcbfc9dfd3.jpeg">
      <meta itemprop="name" content="Ren">
      <meta itemprop="description" content="幸遇三杯酒好，况逢一朵花新。 <br> 片时欢笑且相亲，明日阴晴未定。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYMTICS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构之堆
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-11-25 00:00:00 / 修改时间：12:40:19" itemprop="dateCreated datePublished" datetime="2021-11-25T00:00:00+08:00">2021-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>废话</strong></p>
<p><strong>堆</strong>（Heap）是一种重要的数据结构，但是在大学的数据结构中似乎刚好和这种结构擦肩而过，只记得有一个排序叫“堆排序”，并且在数据结构实习中实现过一次。后来刷LeeCode的时候又遇到了这种结构，所以作文以记之。</p>
<span id="more"></span>

<h2 id="认识堆"><a href="#认识堆" class="headerlink" title="认识堆"></a>认识堆</h2><p>首先看一张堆的图片：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-14a6cde25bdff968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp"></p>
<p>从图片来看，堆似乎和（二叉）树的关系比较亲密，但是，不同的是，堆是用数组实现的二叉树，所以它没有显式地使用父指针或者子指针。堆对节点的大小有要求，比如父节点的值要比每一个子节点的值都要大（最大堆），这个性质和二叉搜索树也有一定的相似之处。</p>
<p>堆的常用操作有：</p>
<ul>
<li>构建优先队列（区别于普通的FIFO队列，优先级高的先出）</li>
<li>堆排序（一种排序算法，时间复杂度近似为O(nlogn)）</li>
<li>快速找出一个集合中的最小值（或者最大值）</li>
</ul>
<h2 id="堆的属性"><a href="#堆的属性" class="headerlink" title="堆的属性"></a>堆的属性</h2><h3 id="最基本的属性"><a href="#最基本的属性" class="headerlink" title="最基本的属性"></a>最基本的属性</h3><p>堆分为两种：最小堆和最大堆。</p>
<p>前面说了，堆对节点的大小有要求，比如在最大堆中，父节点的值要比每一个子节点的值大（所以叫最大堆），最小堆则反之。比如下面就是一个最大堆：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-14a6cde25bdff968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp"></p>
<p>根据这一属性，那么最大堆总是将其中的最大值存放在树的根节点。而对于最小堆，根节点中的元素总是树中的最小值。堆这一属性非常有用，因为可以快速地访问到“最重要”的元素。</p>
<blockquote>
<p><strong>注意：</strong>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p>
</blockquote>
<h3 id="堆和普通树的区别"><a href="#堆和普通树的区别" class="headerlink" title="堆和普通树的区别"></a>堆和普通树的区别</h3><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p>
<ul>
<li><strong>节点的顺序。</strong>在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</li>
<li><strong>内存占用。</strong>普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。</li>
<li><strong>平衡。</strong>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到<strong>O(log n)**。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证</strong>O(log n)** 的性能。</li>
<li><strong>搜索。</strong>在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</li>
</ul>
<h3 id="来自数组的树"><a href="#来自数组的树" class="headerlink" title="来自数组的树"></a>来自数组的树</h3><p>用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间上都是很高效的。</p>
<p>我们准备将上面例子中的树这样存储：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span> ]</span><br></pre></td></tr></table></figure>

<p>就这么多！我们除了一个简单的数组以外，不需要任何额外的空间。</p>
<p>如果我们不允许使用指针，那么我们怎么知道哪一个节点是父节点，哪一个节点是它的子节点呢？问得好！节点在数组中的位置index 和它的父节点以及子节点的索引之间有一个映射关系。</p>
<p>如果 <code>i</code> 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent(i) = floor((i - <span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">left(i)   = <span class="number">2i</span> + <span class="number">1</span></span><br><span class="line">right(i)  = <span class="number">2i</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>right(i)</code> 就是简单的 <code>left(i) + 1</code>。左右节点总是处于相邻的位置。</p>
<p>我们将写公式放到前面的例子中验证一下。</p>
<table>
<thead>
<tr>
<th>Node</th>
<th>Array index (<code>i</code>)</th>
<th>Parent index</th>
<th>Left child</th>
<th>Right child</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>1</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>1</td>
<td>9</td>
<td>10</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong>根节点<code>(10)</code>没有父节点，因为 <code>-1</code> 不是一个有效的数组索引。同样，节点 <code>(2)</code>，<code>(5)</code>和<code>(1)</code> 没有子节点，因为这些索引已经超过了数组的大小，所以我们在使用这些索引值的时候需要保证是有效的索引值。</p>
</blockquote>
<p>复习一下，在最大堆中，父节点的值总是要大于（或者等于）其子节点的值。这意味下面的公式对数组中任意一个索引 <code>i</code>都成立：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span>[<span class="built_in">parent</span>(i)] &gt;= <span class="keyword">array</span>[i]</span><br></pre></td></tr></table></figure>

<p>可以用上面的例子来验证一下这个堆属性。</p>
<p>如你所见，这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。事情比简单的去掉指针要复杂，但这就是交易：我们节约了空间，但是要进行更多计算。幸好这些计算很快并且只需要**O(1)**的时间。</p>
<p>理解数组索引和节点位置之间的关系非常重要。这里有一个更大的堆，它有15个节点被分成了4层：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-4b11a151bf6c2148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp" alt="img"></p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-7515fe1d9f3104ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt="img"></p>
<p>图片中的数字不是节点的值，而是存储这个节点的数组索引！这里是数组索引和树的层级之间的关系：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-d6fd28a1ba7dbb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt="img"></p>
<p>由上图可以看到，数组中父节点总是在子节点的前面。</p>
<p>注意这个方案与一些限制。你可以在普通二叉树中按照下面的方式组织数据，但是在堆中不可以：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-26be199ebd40f8bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp" alt="img"></p>
<p>在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-9590755bc6109a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/413/format/webp" alt="img"></p>
<blockquote>
<p><strong>注意：</strong>你可以使用普通树来模拟堆，但是那对空间是极大的浪费。</p>
</blockquote>
<p>小测验，假设我们有这样一个数组：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>, <span class="number">14</span>, <span class="number">25</span>, <span class="number">33</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">99</span> ]</span><br></pre></td></tr></table></figure>

<p>这是一个有效的堆吗？答案是 yes ！一个从低到高有序排列的数组是以有效的最小堆，我们可以将这个堆画出来：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-525f0584ffbdbbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/219/format/webp" alt="img"></p>
<p>堆属性适用于每一个节点，因为父节点总是比它的字节点小。（你也可以验证一下：一个从高到低有序排列的数组是一个有效的最大堆）</p>
<blockquote>
<p><strong>注意：</strong>并不是每一个最小堆都是一个有序数组！要将堆转换成有序数组，需要使用堆排序。</p>
</blockquote>
<h3 id="更多数学公式"><a href="#更多数学公式" class="headerlink" title="更多数学公式"></a>更多数学公式</h3><p>如果你好奇，这里有更多的公式描述了堆的一些确定属性。你不需要知道这些，但它们有时会派上用场。 可以直接跳过此部分！</p>
<p>树的<em>高度</em>是指从树的根节点到最低的叶节点所需要的步数，或者更正式的定义：高度是指节点之间的边的最大值。一个高度为 h 的堆有 h+1 层。</p>
<p>下面这个对的高度是3，所以它有4层：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-9a3b75e40d3f9f04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp" alt="img"></p>
<p>如果一个堆有 n 个节点，那么它的高度是 *h = floor(log2(n))*。这是因为我们总是要将这一层完全填满以后才会填充新的一层。上面的例子有 15 个节点，所以它的高度是 <code>floor(log2(15)) = floor(3.91) = 3</code>。</p>
<p>如果最下面的一层已经填满，那么那一层包含 <em>2^h</em> 个节点。树中这一层以上所有的节点数目为 <em>2^h - 1</em>。同样是上面这个例子，最下面的一层有8个节点，实际上就是 <code>2^3 = 8</code>。前面的三层一共包含7的节点，即：<code>2^3 - 1 = 8 - 1 = 7</code>。</p>
<p>所以整个堆中的节点数目为：* 2^(h+1) - 1*。上面的例子中，<code>2^4 - 1 = 16 - 1 = 15</code></p>
<p>叶节点总是位于数组的 <em>floor(n/2)</em> 和 <em>n-1</em> 之间。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：</p>
<ul>
<li><code>shiftUp()</code>: 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。这样是这个节点在数组的位置上升。</li>
<li><code>shiftDown()</code>: 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。这个操作也称作“堆化（heapify）”。</li>
</ul>
<p>shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 **O(log n)**。</p>
<p>基于这两个原始操作还有一些其他的操作：</p>
<ul>
<li><code>insert(value)</code>: 在堆的尾部添加一个新的元素，然后使用 <code>shiftUp</code> 来修复对。</li>
<li><code>remove()</code>: 移除并返回最大值（最大堆）或者最小值（最小堆）。为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 <code>shiftDown</code> 方法来修复堆。</li>
<li><code>removeAtIndex(index)</code>: 和 <code>remove()</code> 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。当它与子节点比较位置不是无序时使用 <code>shiftDown()</code>，如果与父节点比较发现无序则使用 <code>shiftUp()</code>。</li>
<li><code>replace(index, value)</code>：将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。由于这个操作破坏了堆属性，所以需要使用 <code>shiftUp()</code> 来修复堆属性。</li>
</ul>
<p>上面所有的操作的时间复杂度都是 **O(log n)**，因为 shiftUp 和 shiftDown 都很费时。还有少数一些操作需要更多的时间：</p>
<ul>
<li><code>search(value)</code>:堆不是为快速搜索而建立的，但是 <code>replace()</code> 和 <code>removeAtIndex()</code> 操作需要找到节点在数组中的index，所以你需要先找到这个index。时间复杂度：**O(n)**。</li>
<li><code>buildHeap(array)</code>:通过反复调用 <code>insert()</code> 方法将一个（无序）数组转换成一个堆。如果你足够聪明，你可以在 <strong>O(n)</strong> 时间内完成。</li>
<li>堆排序：由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。时间复杂度：**O(n lg n)**。</li>
</ul>
<p>堆还有一个 <code>peek()</code> 方法，不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。时间复杂度 <strong>O(1)</strong> 。</p>
<blockquote>
<p><strong>注意：</strong>到目前为止，堆的常用操作还是使用 <code>insert()</code> 插入一个新的元素，和通过 <code>remove()</code>移除最大或者最小值。两者的时间复杂度都是**O(log n)**。其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。</p>
</blockquote>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>我们通过一个插入例子来看看插入操作的细节。我们将数字 <code>16</code> 插入到这个堆中：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-51fd43a2d2191488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp" alt="img"></p>
<p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。</p>
<p>第一股是将新的元素插入到数组的尾部。数组变成：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">16</span> ]</span><br></pre></td></tr></table></figure>

<p>相应的树变成了：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-7dd89da71927acb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp" alt="img"></p>
<p><code>16</code> 被添加最后一行的第一个空位。</p>
<p>不行的是，现在堆属性不满足，因为 <code>2</code> 在 <code>16</code> 的上面，我们需要将大的数字在上面（这是一个最大堆）</p>
<p>为了恢复堆属性，我们需要交换 <code>16</code> 和 <code>2</code>。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-785a7a6cd104f775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/204/format/webp" alt="img"></p>
<p>现在还没有完成，因为 <code>10</code> 也比 <code>16</code> 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 <strong>shift-up</strong>，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。</p>
<p>最后我们得到的堆：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-d7dae273e1f5a0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/192/format/webp" alt="img"></p>
<p>现在每一个父节点都比它的子节点大。</p>
<h3 id="删除根节点"><a href="#删除根节点" class="headerlink" title="删除根节点"></a>删除根节点</h3><p>我们将这个树中的 <code>(10)</code> 删除：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-7eb32c6486a44f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp" alt="img"></p>
<p>现在顶部有一个空的节点，怎么处理？</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-71783aa7bd24a51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp" alt="img"></p>
<p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-c28b15dc371b8e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp" alt="img"></p>
<p>现在来看怎么 <strong>shift-down</strong> <code>(1)</code>。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 <code>7</code> 和 <code>2</code>。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 <code>7</code> 和 <code>1</code>，现在树变成了：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-bfc42e89b5411f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/190/format/webp" alt="img"></p>
<p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-8b04275965f88961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/208/format/webp" alt="img"></p>
<h3 id="删除任意节点"><a href="#删除任意节点" class="headerlink" title="删除任意节点"></a>删除任意节点</h3><p>绝大多数时候你需要删除的是堆的根节点，因为这就是堆的设计用途。</p>
<p>但是，删除任意节点也很有用。这是 <code>remove()</code> 的通用版本，它可能会使用到 <code>shiftDown</code> 和 <code>shiftUp</code>。</p>
<p>我们还是用前面的例子，删除 <code>(7)</code>:</p>
<p>对应的数组是</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span> ]</span><br></pre></td></tr></table></figure>

<p>你知道，移除一个元素会破坏最大堆或者最小堆属性。我们需要将删除的元素和最后一个元素交换：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span> ]</span><br></pre></td></tr></table></figure>

<p>最后一个元素就是我们需要返回的元素；然后调用 <code>removeLast()</code> 来将它删除。 <code>(1)</code> 比它的子节点小，所以需要 <code>shiftDown()</code> 来修复。</p>
<p>然而，shift down 不是我们要处理的唯一情况。也有可能我们需要 shift up。考虑一下从下面的堆中删除 <code>(5)</code> 会发生什么：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4064751-ef711e0072fc773a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/219/format/webp" alt="img"></p>
<p>现在 <code>(5)</code> 和 <code>(8)</code> 交换了。因为 <code>(8)</code> 比它的父节点大，我们需要 <code>shiftUp()</code>。</p>
<h2 id="实操（代码）"><a href="#实操（代码）" class="headerlink" title="实操（代码）"></a>实操（代码）</h2><p>前面虽然提到了很多的操作，但是实际上重要的主要是堆排序相关的，所以这里有选择的实现这个操作。另外由于笔者最近在学习Go语言，所以就用Go语言来实现了。</p>
<p>我们这里以最大堆为例，来讲述这个过程：</p>
<h3 id="调整位置"><a href="#调整位置" class="headerlink" title="调整位置"></a>调整位置</h3><p>先把视线放在局部，如何调整这个局部的堆满足顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxHeapify</span><span class="params">(a []<span class="keyword">int</span>, i, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取左右节点的下标，并默认这个父节点是最大的</span></span><br><span class="line">	l, r, largest := i*<span class="number">2</span>+<span class="number">1</span>, i*<span class="number">2</span>+<span class="number">2</span>, i</span><br><span class="line">    <span class="comment">// 调整获取三个中最大的</span></span><br><span class="line">	<span class="keyword">if</span> l &lt; heapSize &amp;&amp; a[l] &gt; a[largest] &#123;</span><br><span class="line">		largest = l</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r &lt; heapSize &amp;&amp; a[r] &gt; a[largest] &#123;</span><br><span class="line">		largest = r</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 假如largest变了，那说明需要交换以使得最大的在上面</span></span><br><span class="line">	<span class="keyword">if</span> largest != i &#123;</span><br><span class="line">		a[i], a[largest] = a[largest], a[i]</span><br><span class="line">        <span class="comment">// 瘦死的骆驼比马大，刚刚被比下去的那个有可能在他的子树中是最大的</span></span><br><span class="line">		maxHeapify(a, largest, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面做了界限判断，以防止数组越界</p>
<h3 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h3><p>有了上面这个操作，我们就可以开始构造堆了：</p>
<p>我们只需要从最后一个节点开始，对每一个节点调用上面那个调整函数即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(a []<span class="keyword">int</span>, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := heapSize; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		maxHeapify(a, i, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有一个问题，在这个二叉树中最后一层的许多节点并没有左右子节点，这也就是说，我们可以跳过一部分没有子节点的节点：（为什么是1/2，画个图看看）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(a []<span class="keyword">int</span>, heapSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		maxHeapify(a, i, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取堆顶"><a href="#取堆顶" class="headerlink" title="取堆顶"></a>取堆顶</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums[0]就是堆顶元素</span></span><br><span class="line">result := nums[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 取完堆顶要重新调整堆，具体就是把最后一个元素放在nums[0]的位置，然后调整</span></span><br><span class="line">nums[<span class="number">0</span>] = nums[nums.length - <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 注意堆的大小减少了</span></span><br><span class="line">maxHeapify(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Java完整实现"><a href="#Java完整实现" class="headerlink" title="Java完整实现"></a>Java完整实现</h3><p>参考一道Leetcode题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = (nums.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            adjustHeap(nums, i, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans = getMax(nums, nums.length - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[heapSize - <span class="number">1</span>];</span><br><span class="line">        adjustHeap(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span> root, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = root * <span class="number">2</span> + <span class="number">1</span>, r = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> largest = root;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; nums[largest] &lt; nums[l]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; nums[largest] &lt; nums[r]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != root) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[largest];</span><br><span class="line">            nums[largest] = nums[root];</span><br><span class="line">            nums[root] = tmp;</span><br><span class="line">            adjustHeap(nums, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="语言自带API"><a href="#语言自带API" class="headerlink" title="语言自带API"></a>语言自带API</h2><h3 id="Java：priorityQueue"><a href="#Java：priorityQueue" class="headerlink" title="Java：priorityQueue"></a>Java：priorityQueue</h3><p>优先队列priorityQueue是Queue接口的实现，可以对其中元素进行排序，可以放基本的包装类型或自定义的类，对于基本类型的包装类，优先队列中元素的默认排列顺序是升序，但是对于自定义类来说，需要自定义比较类</p>
<p><strong>priorityQueue的内部实现</strong><br>PriorityQueue对元素采用的是堆排序，头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小），整个堆并不是有序的。<br>方法iterator()中提供的迭代器可能只是对整个数组的依次遍历。也就只能保证数组的第一个元素是最小的 </p>
<p>PriorityQueue的iterator（）不保证以任何特定顺序遍历队列元素。若想按特定顺序遍历，先将队列转成数组，然后排序遍历。Arrays.sort(pq.toArray())</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">peek()<span class="comment">//返回队首元素</span></span><br><span class="line">poll()<span class="comment">//返回队首元素，队首元素出队列</span></span><br><span class="line">add()<span class="comment">//添加元素</span></span><br><span class="line">size()<span class="comment">//返回队列元素个数</span></span><br><span class="line">isEmpty()<span class="comment">//判断队列是否为空，为空返回true,不空返回false</span></span><br></pre></td></tr></table></figure>

<p>更多方法请参考：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/PriorityQueue.html">PriorityQueue (Java SE 15 &amp; JDK 15) (oracle.com)</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b526aa481b1">数据结构：堆（Heap） - 简书 (jianshu.com)</a> 唐先僧 2018.08.12</li>
<li><a target="_blank" rel="noopener" href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap">raywenderlich/swift-algorithm-club</a> 英文原文</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hetaoyuan/p/12294576.html">Java优先队列的用法 - 何浩源 - 博客园 (cnblogs.com)</a> 2020-02-11</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/PriorityQueue.html">PriorityQueue (Java SE 15 &amp; JDK 15) (oracle.com)</a></li>
</ol>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A0%86/" rel="tag"># 堆</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/28891.html" rel="prev" title="算法 | 双指针技巧">
                  <i class="fa fa-chevron-left"></i> 算法 | 双指针技巧
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/37169.html" rel="next" title="分布式与微服务笔记">
                  分布式与微服务笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ren</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.2" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"ignores":null,"url":"https://blog.lymtics.top/posts/64693.html"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
